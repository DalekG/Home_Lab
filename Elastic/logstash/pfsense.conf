input {
  # Beats input for Filebeat
  beats {
    port => 5044
    ssl => false
  }

  # Syslog input for direct pfSense logging
  syslog {
    port => 5140
    type => "pfsense-syslog"
  }
}

filter {
  # Only process pfSense logs
  if [event][module] == "system" and [log][file][path] =~ /pfsense/ or [type] == "pfsense-syslog" or [event][module] == "pfsense" {

    # Parse the syslog format with ISO8601 timestamp
    grok {
      match => {
        "message" => [
          # ISO8601 timestamp format (2025-12-28T20:04:25+00:00)
          "%{TIMESTAMP_ISO8601:syslog_timestamp} %{SYSLOGHOST:hostname} %{DATA:process}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:pfsense_message}",
          # Traditional syslog format
          "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:hostname} %{DATA:process}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:pfsense_message}",
          # Alternative format
          "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:hostname} %{GREEDYDATA:pfsense_message}"
        ]
      }
      add_tag => ["pfsense"]
    }

    # Parse pfSense filterlog (firewall rules)
    if [process] == "filterlog" {
      # Use CSV filter for cleaner parsing
      csv {
        source => "pfsense_message"
        separator => ","
        columns => [
          "rule_number", "sub_rule", "anchor", "tracker", "interface",
          "reason", "action", "direction", "ip_version"
        ]
      }

      # Split remaining fields based on IP version
      if [ip_version] == "4" {
        # IPv4: Continue parsing after ip_version
        dissect {
          mapping => {
            "pfsense_message" => "%{rule_number},%{sub_rule},%{anchor},%{tracker},%{interface},%{reason},%{action},%{direction},%{ip_version},%{tos},%{ecn},%{ttl},%{id},%{offset},%{flags},%{proto_id},%{proto},%{length},%{src_ip},%{dst_ip},%{proto_data}"
          }
        }

        # Parse protocol-specific data
        if [proto] == "udp" {
          dissect {
            mapping => {
              "proto_data" => "%{src_port},%{dst_port},%{data_length}"
            }
          }
        }

        if [proto] == "tcp" {
          dissect {
            mapping => {
              "proto_data" => "%{src_port},%{dst_port},%{data_length},%{tcp_flags},%{sequence},%{ack},%{window},%{urg},%{options}"
            }
          }
        }

        if [proto] == "icmp" {
          dissect {
            mapping => {
              "proto_data" => "%{icmp_type},%{icmp_code}"
            }
          }
        }
      }

      # Parse IPv6
      if [ip_version] == "6" {
        dissect {
          mapping => {
            "pfsense_message" => "%{rule_number},%{sub_rule},%{anchor},%{tracker},%{interface},%{reason},%{action},%{direction},%{ip_version},%{class},%{flow_label},%{hop_limit},%{proto},%{proto_id},%{length},%{src_ip},%{dst_ip},%{proto_data}"
          }
        }

        # Parse protocol-specific data for IPv6
        if [proto] == "udp" or [proto] == "UDP" {
          dissect {
            mapping => {
              "proto_data" => "%{src_port},%{dst_port},%{data_length}"
            }
          }
        }

        if [proto] == "tcp" or [proto] == "TCP" {
          dissect {
            mapping => {
              "proto_data" => "%{src_port},%{dst_port},%{data_length},%{tcp_flags},%{sequence},%{ack},%{window},%{urg},%{options}"
            }
          }
        }
      }
      # Convert data types
      mutate {
        convert => {
          "src_port" => "integer"
          "dst_port" => "integer"
          "length" => "integer"
          "ttl" => "integer"
          "data_length" => "integer"
        }
      }

      mutate {
        add_field => { "[event][category]" => "network" }
        add_field => { "[event][type]" => "connection" }
        add_field => { "[network][direction]" => "%{direction}" }
        add_field => { "[network][transport]" => "%{proto}" }
        add_tag => ["firewall"]
      }
    }

    # Parse pfSense DHCP logs
    if [process] == "dhcpd" {
      grok {
        match => {
          "pfsense_message" => [
            "DHCPACK on %{IP:assigned_ip} to %{COMMONMAC:client_mac}( \(%{DATA:client_hostname}\))? via %{DATA:interface}",
            "DHCPREQUEST for %{IP:requested_ip}( \(%{IP:server_ip}\))? from %{COMMONMAC:client_mac}( \(%{DATA:client_hostname}\))? via %{DATA:interface}",
            "DHCPDISCOVER from %{COMMONMAC:client_mac}( \(%{DATA:client_hostname}\))? via %{DATA:interface}"
          ]
        }
      }
      mutate {
        add_tag => ["dhcp"]
      }
    }

    # Parse pfSense OpenVPN logs
    if [process] =~ /openvpn/ {
      grok {
        match => {
          "pfsense_message" => [
            "%{IP:client_ip}:%{INT:client_port} \[%{DATA:vpn_user}\] Peer Connection Initiated with \[AF_INET\]%{IP:server_ip}:%{INT:server_port}",
            "%{IP:client_ip}:%{INT:client_port} SENT CONTROL \[%{DATA:vpn_user}\]: '%{GREEDYDATA:control_message}'",
            "%{GREEDYDATA:vpn_message}"
          ]
        }
      }
      mutate {
        add_tag => ["vpn", "openvpn"]
      }
    }

    # Parse pfSense authentication logs
    if [process] =~ /sshd|webConfigurator/ {
      grok {
        match => {
          "pfsense_message" => [
            "Successful login for user '?%{USER:auth_user}'? from: %{IP:src_ip}",
            "Failed login for user '?%{USER:auth_user}'? from: %{IP:src_ip}",
            "Accepted password for %{USER:auth_user} from %{IP:src_ip} port %{INT:src_port}",
            "Failed password for %{USER:auth_user} from %{IP:src_ip} port %{INT:src_port}"
          ]
        }
      }

      if "Failed" in [pfsense_message] {
        mutate {
          add_field => { "[event][outcome]" => "failure" }
          add_tag => ["authentication_failure"]
        }
      } else if "Successful" in [pfsense_message] or "Accepted" in [pfsense_message] {
        mutate {
          add_field => { "[event][outcome]" => "success" }
          add_tag => ["authentication_success"]
        }
      }

      mutate {
        add_tag => ["authentication"]
      }
    }

    # Convert timestamp - handle both ISO8601 and traditional syslog
    date {
      match => [
        "syslog_timestamp",
        "ISO8601",
        "MMM dd HH:mm:ss",
        "MMM  d HH:mm:ss"
      ]
      target => "@timestamp"
    }

    # GeoIP enrichment for external IPs
    if [src_ip] {
      if [src_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
        geoip {
          source => "src_ip"
          target => "src_geo"
        }
      }
    }

    if [dst_ip] {
      if [dst_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
        geoip {
          source => "dst_ip"
          target => "dst_geo"
        }
      }
    }

    # Clean up temporary fields
    mutate {
      remove_field => ["proto_data", "syslog_timestamp", "pfsense_message"]
    }
  }
}

output {
  # Output to Elasticsearch with index per day
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "pfsense-%{+YYYY.MM.dd}"
    # user => "elastic"
    # password => "changeme"
  }

  # Debugging output (comment out in production)
  # stdout {
  #   codec => rubydebug
  # }
}
